<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>登录</title>

    <style>
        /* =========================================
           1. 樱花特效 CSS (整合自 sakura1.css)
           ========================================= */
        #sakura {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* 确保背景在内容下方 */
            pointer-events: none; /* 让鼠标事件穿透背景，不影响页面交互 */
        }

        /* =========================================
           2. 页面布局与组件样式
           ========================================= */
        :root {
            --primary-color: #ff7eb3;
            --primary-hover: #ff5a9f;
            --glass-bg: rgba(255, 255, 255, 0.65);
            --glass-border: rgba(255, 255, 255, 0.8);
            --text-color: #4a4a4a;
            --text-light: #888;
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* 防止滚动条出现 */
            background-color: #fad0c4; /* 樱花背景加载前的备用色 */
            background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%);
        }

        /* 登录卡片容器 - 玻璃拟态效果 */
        .login-card {
            width: 100%;
            max-width: 400px;
            padding: 40px;
            margin: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            position: relative;
            transform: translateY(20px);
            opacity: 0;
            animation: fadeInUp 0.8s ease-out forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .login-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .login-header h2 {
            color: var(--text-color);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .login-header p {
            color: var(--text-light);
            font-size: 14px;
        }

        /* 表单元素 */
        .form-group {
            margin-bottom: 20px;
            position: relative;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-color);
            font-size: 14px;
            font-weight: 500;
        }

        .input-wrapper {
            position: relative;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            padding-right: 40px; /* 为图标留空间 */
            border: 2px solid transparent;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
            font-size: 15px;
            color: var(--text-color);
            transition: all 0.3s ease;
            outline: none;
        }

        .form-input:focus {
            background: #fff;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(255, 126, 179, 0.1);
        }

        .form-input::placeholder {
            color: #bbb;
        }

        /* 密码切换图标 */
        .toggle-password {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: #aaa;
            transition: color 0.3s;
            width: 20px;
            height: 20px;
        }

        .toggle-password:hover {
            color: var(--primary-color);
        }

        /* 辅助选项：记住我 & 忘记密码 */
        .form-options {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            font-size: 13px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            color: var(--text-color);
        }

        .checkbox-label input {
            margin-right: 8px;
            accent-color: var(--primary-color);
            width: 16px;
            height: 16px;
        }

        .forgot-link {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: opacity 0.3s;
        }

        .forgot-link:hover {
            opacity: 0.8;
        }

        /* 登录按钮 */
        .btn-submit {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary-color) 0%, #ff5a9f 100%);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }

        .btn-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 126, 179, 0.4);
        }

        .btn-submit:active {
            transform: translateY(0);
        }

        .btn-submit:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* 加载动画 */
        .spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto;
        }

        .btn-submit.loading .btn-text {
            display: none;
        }

        .btn-submit.loading .spinner {
            display: block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 底部链接 */
        .login-footer {
            margin-top: 24px;
            text-align: center;
            font-size: 14px;
            color: var(--text-light);
        }

        .login-footer a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 600;
        }

        /* 自定义 Toast 消息提示 */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }

        .toast {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 50px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            font-size: 14px;
            color: var(--text-color);
            border-left: 4px solid #ccc;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.success { border-left-color: #4caf50; }
        .toast.error { border-left-color: #ff5252; }
        .toast.info { border-left-color: #2196f3; }

        .toast-icon {
            margin-right: 10px;
            font-size: 18px;
        }

        /* 响应式适配 */
        @media (max-width: 480px) {
            .login-card {
                padding: 30px 20px;
                margin: 15px;
            }
        }
    </style>
</head>
<body>

    <!-- 1. 樱花特效画布 -->
    <canvas id="sakura"></canvas>

    <!-- 2. 樱花特效所需的 Shader 脚本 -->
    <script id="sakura_point_vsh" type="x-shader/x_vertex">
        uniform mat4 uProjection;
        uniform mat4 uModelview;
        uniform vec3 uResolution;
        uniform vec3 uOffset;
        uniform vec3 uDOF;
        uniform vec3 uFade;
        attribute vec3 aPosition;
        attribute vec3 aEuler;
        attribute vec2 aMisc;
        varying vec3 pposition;
        varying float psize;
        varying float palpha;
        varying float pdist;
        varying vec3 normX;
        varying vec3 normY;
        varying vec3 normZ;
        varying vec3 normal;
        varying float diffuse;
        varying float specular;
        varying float rstop;
        varying float distancefade;
        void main(void) {
            vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);
            gl_Position = uProjection * pos;
            gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;
            pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz);
            palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);
            vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler);
            mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x);
            mat3 roty = mat3(elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y);
            mat3 rotz = mat3(elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0);
            mat3 rotmat = rotx * roty * rotz; normal = rotmat[2];
            mat3 trrotm = mat3(rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2]);
            normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2];
            const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);
            float tmpdfs = dot(lit, normal);
            if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); }
            diffuse = 0.4 + tmpdfs;
            vec3 eyev = normalize(-pos.xyz);
            if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); }
            else { specular = 0.0; }
            rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);
            rstop = pow(rstop, 0.5);
            distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));
        }
    </script>
    <script id="sakura_point_fsh" type="x-shader/x_fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform vec3 uDOF; uniform vec3 uFade;
        const vec3 fadeCol = vec3(0.08, 0.03, 0.06);
        varying vec3 pposition; varying float psize; varying float palpha; varying float pdist;
        varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal;
        varying float diffuse; varying float specular; varying float rstop; varying float distancefade;
        float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; }
        void main(void) {
            vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;
            vec3 d = vec3(0.0, 0.0, -1.0);
            float nd = normZ.z;
            if(abs(nd) < 0.0001) discard;
            float np = dot(normZ, p);
            vec3 tp = p + d * np / nd;
            vec2 coord = vec2(dot(normX, tp), dot(normY, tp));
            const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068;
            mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs);
            vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm;
            float r;
            if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); }
            else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); }
            if(r > rstop) discard;
            vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);
            float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));
            col *= vec3(1.0, grady, grady);
            col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3));
            col = col * diffuse + specular;
            col = mix(fadeCol, col, distancefade);
            float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0;
            alpha = smoothstep(0.0, 1.0, alpha) * palpha;
            gl_FragColor = vec4(col * 0.5, alpha);
        }
    </script>
    <script id="fx_common_vsh" type="x-shader/x_vertex">
        uniform vec3 uResolution;
        attribute vec2 aPosition;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) {
            gl_Position = vec4(aPosition, 0.0, 1.0);
            texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);
            screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);
        }
    </script>
    <script id="bg_fsh" type="x-shader/x_fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform vec2 uTimes;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) {
            vec3 col; float c;
            vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);
            c = exp(-pow(length(tmpv) * 1.8, 2.0));
            col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);
            gl_FragColor = vec4(col * 0.5, 1.0);
        }
    </script>
    <script id="fx_brightbuf_fsh" type="x-shader/x_fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D uSrc; uniform vec2 uDelta;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) {
            vec4 col = texture2D(uSrc, texCoord);
            gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);
        }
    </script>
    <script id="fx_dirblur_r4_fsh" type="x-shader/x_fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) {
            vec4 col = texture2D(uSrc, texCoord);
            col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);
            col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);
            col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);
            col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);
            gl_FragColor = col / 5.0;
        }
    </script>
    <script id="fx_common_fsh" type="x-shader/x_fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D uSrc; uniform vec2 uDelta;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) { gl_FragColor = texture2D(uSrc, texCoord); }
    </script>
    <script id="pp_final_vsh" type="x-shader/x_vertex">
        uniform vec3 uResolution;
        attribute vec2 aPosition;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) {
            gl_Position = vec4(aPosition, 0.0, 1.0);
            texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);
            screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);
        }
    </script>
    <script id="pp_final_fsh" type="x-shader/x_fragment">
        #ifdef GL_ES
        precision highp float;
        #endif
        uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta;
        varying vec2 texCoord; varying vec2 screenCoord;
        void main(void) {
            vec4 srccol = texture2D(uSrc, texCoord) * 2.0;
            vec4 bloomcol = texture2D(uBloom, texCoord);
            vec4 col;
            col = srccol + bloomcol * (vec4(1.0) + srccol);
            col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);
            col = pow(col, vec4(0.45454545454545));
            gl_FragColor = vec4(col.rgb, 1.0);
            gl_FragColor.a = 1.0;
        }
    </script>

    <!-- 3. 登录表单 UI -->
    <main class="login-card">
        <header class="login-header">
            <h2>欢迎回来</h2>
            <p>登录您的账户以继续</p>
        </header>

        <form id="loginForm" action="/login" method="POST" novalidate>
            <div class="form-group">
                <label for="email" class="form-label">电子邮箱</label>
                <div class="input-wrapper">
                    <input type="email" id="email" class="form-input" placeholder="name@example.com" required autocomplete="email">
                </div>
            </div>

            <div class="form-group">
                <label for="password" class="form-label">密码</label>
                <div class="input-wrapper">
                    <input type="password" id="password" class="form-input" placeholder="请输入密码" required autocomplete="current-password">
                    <!-- SVG 图标：眼睛 -->
                    <svg class="toggle-password" id="togglePassword" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" fill="currentColor"/>
                    </svg>
                </div>
            </div>

            <div class="form-options">
                <label class="checkbox-label">
                    <input type="checkbox" id="rememberMe">
                    记住我
                </label>
                <a href="#" class="forgot-link">忘记密码？</a>
            </div>

            <button type="submit" class="btn-submit" id="submitBtn">
                <span class="btn-text">立即登录</span>
                <span class="spinner"></span>
            </button>
        </form>

        <footer class="login-footer">
            <!--<p>还没有账号？ <a href="#">立即注册(不开放注册)</a></p>-->
            <p><a href="#">不开放注册</a></p>
        </footer>
    </main>

    <!-- Toast 容器 -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- 4. 脚本逻辑：樱花特效 + 表单交互 -->
    <script>
        // =========================================
        // Part A: 樱花特效逻辑 (整合自 sakura1.js)
        // =========================================
        (function() {
            var Vector3 = {};
            var Matrix44 = {};
            Vector3.create = function(x, y, z) { return {'x':x, 'y':y, 'z':z}; };
            Vector3.dot = function (v0, v1) { return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z; };
            Vector3.cross = function (v, v0, v1) {
                v.x = v0.y * v1.z - v0.z * v1.y;
                v.y = v0.z * v1.x - v0.x * v1.z;
                v.z = v0.x * v1.y - v0.y * v1.x;
            };
            Vector3.normalize = function (v) {
                var l = v.x * v.x + v.y * v.y + v.z * v.z;
                if(l > 0.00001) { l = 1.0 / Math.sqrt(l); v.x *= l; v.y *= l; v.z *= l; }
            };
            Vector3.arrayForm = function(v) {
                if(v.array) { v.array[0] = v.x; v.array[1] = v.y; v.array[2] = v.z; }
                else { v.array = new Float32Array([v.x, v.y, v.z]); }
                return v.array;
            };
            Matrix44.createIdentity = function () { return new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]); };
            Matrix44.loadProjection = function (m, aspect, vdeg, near, far) {
                var h = near * Math.tan(vdeg * Math.PI / 180.0 * 0.5) * 2.0;
                var w = h * aspect;
                m[0] = 2.0 * near / w; m[1] = 0.0; m[2] = 0.0; m[3] = 0.0;
                m[4] = 0.0; m[5] = 2.0 * near / h; m[6] = 0.0; m[7] = 0.0;
                m[8] = 0.0; m[9] = 0.0; m[10] = -(far + near) / (far - near); m[11] = -1.0;
                m[12] = 0.0; m[13] = 0.0; m[14] = -2.0 * far * near / (far - near); m[15] = 0.0;
            };
            Matrix44.loadLookAt = function (m, vpos, vlook, vup) {
                var frontv = Vector3.create(vpos.x - vlook.x, vpos.y - vlook.y, vpos.z - vlook.z);
                Vector3.normalize(frontv);
                var sidev = Vector3.create(1.0, 0.0, 0.0);
                Vector3.cross(sidev, vup, frontv);
                Vector3.normalize(sidev);
                var topv = Vector3.create(1.0, 0.0, 0.0);
                Vector3.cross(topv, frontv, sidev);
                Vector3.normalize(topv);
                m[0] = sidev.x; m[1] = topv.x; m[2] = frontv.x; m[3] = 0.0;
                m[4] = sidev.y; m[5] = topv.y; m[6] = frontv.y; m[7] = 0.0;
                m[8] = sidev.z; m[9] = topv.z; m[10] = frontv.z; m[11] = 0.0;
                m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]);
                m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]);
                m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]);
                m[15] = 1.0;
            };
            var timeInfo = {'start':0, 'prev':0, 'delta':0, 'elapsed':0};
            var gl;
            var renderSpec = {'width':0, 'height':0, 'aspect':1, 'array':new Float32Array(3), 'halfWidth':0, 'halfHeight':0, 'halfArray':new Float32Array(3)};
            renderSpec.setSize = function(w, h) {
                renderSpec.width = w; renderSpec.height = h; renderSpec.aspect = renderSpec.width / renderSpec.height;
                renderSpec.array[0] = renderSpec.width; renderSpec.array[1] = renderSpec.height; renderSpec.array[2] = renderSpec.aspect;
                renderSpec.halfWidth = Math.floor(w / 2); renderSpec.halfHeight = Math.floor(h / 2);
                renderSpec.halfArray[0] = renderSpec.halfWidth; renderSpec.halfArray[1] = renderSpec.halfHeight;
                renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight;
            };
            function deleteRenderTarget(rt) {
                gl.deleteFramebuffer(rt.frameBuffer);
                gl.deleteRenderbuffer(rt.renderBuffer);
                gl.deleteTexture(rt.texture);
            }
            function createRenderTarget(w, h) {
                var ret = {'width':w, 'height':h, 'sizeArray':new Float32Array([w, h, w / h]), 'dtxArray':new Float32Array([1.0 / w, 1.0 / h])};
                ret.frameBuffer = gl.createFramebuffer();
                ret.renderBuffer = gl.createRenderbuffer();
                ret.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, ret.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ret.texture, 0);
                gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, ret.renderBuffer);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                return ret;
            }
            function compileShader(shtype, shsrc) {
                var retsh = gl.createShader(shtype);
                gl.shaderSource(retsh, shsrc);
                gl.compileShader(retsh);
                if(!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) { var errlog = gl.getShaderInfoLog(retsh); gl.deleteShader(retsh); console.error(errlog); return null; }
                return retsh;
            }
            function createShader(vtxsrc, frgsrc, uniformlist, attrlist) {
                var vsh = compileShader(gl.VERTEX_SHADER, vtxsrc);
                var fsh = compileShader(gl.FRAGMENT_SHADER, frgsrc);
                if(vsh == null || fsh == null) return null;
                var prog = gl.createProgram();
                gl.attachShader(prog, vsh);
                gl.attachShader(prog, fsh);
                gl.deleteShader(vsh);
                gl.deleteShader(fsh);
                gl.linkProgram(prog);
                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) { var errlog = gl.getProgramInfoLog(prog); console.error(errlog); return null; }
                if(uniformlist) { prog.uniforms = {}; for(var i = 0; i < uniformlist.length; i++) prog.uniforms[uniformlist[i]] = gl.getUniformLocation(prog, uniformlist[i]); }
                if(attrlist) { prog.attributes = {}; for(var i = 0; i < attrlist.length; i++) { var attr = attrlist[i]; prog.attributes[attr] = gl.getAttribLocation(prog, attr); } }
                return prog;
            }
            function useShader(prog) { gl.useProgram(prog); for(var attr in prog.attributes) gl.enableVertexAttribArray(prog.attributes[attr]); }
            function unuseShader(prog) { for(var attr in prog.attributes) gl.disableVertexAttribArray(prog.attributes[attr]); gl.useProgram(null); }
            var projection = {'angle':60, 'nearfar':new Float32Array([0.1, 100.0]), 'matrix':Matrix44.createIdentity()};
            var camera = {'position':Vector3.create(0, 0, 100), 'lookat':Vector3.create(0, 0, 0), 'up':Vector3.create(0, 1, 0), 'dof':Vector3.create(10.0, 4.0, 8.0), 'matrix':Matrix44.createIdentity()};
            var pointFlower = {};
            var sceneStandBy = false;
            var BlossomParticle = function () {
                this.velocity = new Array(3);
                this.rotation = new Array(3);
                this.position = new Array(3);
                this.euler = new Array(3);
                this.size = 1.0;
                this.alpha = 1.0;
                this.zkey = 0.0;
            };
            BlossomParticle.prototype.setVelocity = function (vx, vy, vz) { this.velocity[0] = vx; this.velocity[1] = vy; this.velocity[2] = vz; };
            BlossomParticle.prototype.setRotation = function (rx, ry, rz) { this.rotation[0] = rx; this.rotation[1] = ry; this.rotation[2] = rz; };
            BlossomParticle.prototype.setPosition = function (nx, ny, nz) { this.position[0] = nx; this.position[1] = ny; this.position[2] = nz; };
            BlossomParticle.prototype.setEulerAngles = function (rx, ry, rz) { this.euler[0] = rx; this.euler[1] = ry; this.euler[2] = rz; };
            BlossomParticle.prototype.setSize = function (s) { this.size = s; };
            BlossomParticle.prototype.update = function (dt, et) {
                this.position[0] += this.velocity[0] * dt;
                this.position[1] += this.velocity[1] * dt;
                this.position[2] += this.velocity[2] * dt;
                this.euler[0] += this.rotation[0] * dt;
                this.euler[1] += this.rotation[1] * dt;
                this.euler[2] += this.rotation[2] * dt;
            };
            function createPointFlowers() {
                var prm = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
                renderSpec.pointSize = {'min':prm[0], 'max':prm[1]};
                var vtxsrc = document.getElementById("sakura_point_vsh").textContent;
                var frgsrc = document.getElementById("sakura_point_fsh").textContent;
                pointFlower.program = createShader(vtxsrc, frgsrc, ['uProjection', 'uModelview', 'uResolution', 'uOffset', 'uDOF', 'uFade'], ['aPosition', 'aEuler', 'aMisc']);
                useShader(pointFlower.program);
                pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]);
                pointFlower.fader = Vector3.create(0.0, 10.0, 0.0);
                pointFlower.numFlowers = 1600;
                pointFlower.particles = new Array(pointFlower.numFlowers);
                pointFlower.dataArray = new Float32Array(pointFlower.numFlowers * (3 + 3 + 2));
                pointFlower.positionArrayOffset = 0;
                pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3;
                pointFlower.miscArrayOffset = pointFlower.numFlowers * 6;
                pointFlower.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                unuseShader(pointFlower.program);
                for(var i = 0; i < pointFlower.numFlowers; i++) pointFlower.particles[i] = new BlossomParticle();
            }
            function initPointFlowers() {
                pointFlower.area = Vector3.create(20.0, 20.0, 20.0);
                pointFlower.area.x = pointFlower.area.y * renderSpec.aspect;
                pointFlower.fader.x = 10.0; pointFlower.fader.y = pointFlower.area.z; pointFlower.fader.z = 0.1;
                var PI2 = Math.PI * 2.0;
                var tmpv3 = Vector3.create(0, 0, 0);
                var tmpv = 0;
                var symmetryrand = function() {return (Math.random() * 2.0 - 1.0);};
                for(var i = 0; i < pointFlower.numFlowers; i++) {
                    var tmpprtcl = pointFlower.particles[i];
                    tmpv3.x = symmetryrand() * 0.3 + 0.8;
                    tmpv3.y = symmetryrand() * 0.2 - 1.0;
                    tmpv3.z = symmetryrand() * 0.3 + 0.5;
                    Vector3.normalize(tmpv3);
                    tmpv = 2.0 + Math.random() * 1.0;
                    tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv);
                    tmpprtcl.setRotation(symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5);
                    tmpprtcl.setPosition(symmetryrand() * pointFlower.area.x, symmetryrand() * pointFlower.area.y, symmetryrand() * pointFlower.area.z);
                    tmpprtcl.setEulerAngles(Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0);
                    tmpprtcl.setSize(0.9 + Math.random() * 0.1);
                }
            }
            function renderPointFlowers() {
                var PI2 = Math.PI * 2.0;
                var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z];
                var repeatPos = function (prt, cmp, limit) { if(Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) { if(prt.position[cmp] > 0) prt.position[cmp] -= limit * 2.0; else prt.position[cmp] += limit * 2.0; } };
                var repeatEuler = function (prt, cmp) { prt.euler[cmp] = prt.euler[cmp] % PI2; if(prt.euler[cmp] < 0.0) prt.euler[cmp] += PI2; };
                for(var i = 0; i < pointFlower.numFlowers; i++) {
                    var prtcl = pointFlower.particles[i];
                    prtcl.update(timeInfo.delta, timeInfo.elapsed);
                    repeatPos(prtcl, 0, pointFlower.area.x); repeatPos(prtcl, 1, pointFlower.area.y); repeatPos(prtcl, 2, pointFlower.area.z);
                    repeatEuler(prtcl, 0); repeatEuler(prtcl, 1); repeatEuler(prtcl, 2);
                    prtcl.alpha = 1.0;
                    prtcl.zkey = (camera.matrix[2] * prtcl.position[0] + camera.matrix[6] * prtcl.position[1] + camera.matrix[10] * prtcl.position[2] + camera.matrix[14]);
                }
                pointFlower.particles.sort(function(p0, p1){return p0.zkey - p1.zkey;});
                var ipos = pointFlower.positionArrayOffset;
                var ieuler = pointFlower.eulerArrayOffset;
                var imisc = pointFlower.miscArrayOffset;
                for(var i = 0; i < pointFlower.numFlowers; i++) {
                    var prtcl = pointFlower.particles[i];
                    pointFlower.dataArray[ipos] = prtcl.position[0]; pointFlower.dataArray[ipos + 1] = prtcl.position[1]; pointFlower.dataArray[ipos + 2] = prtcl.position[2]; ipos += 3;
                    pointFlower.dataArray[ieuler] = prtcl.euler[0]; pointFlower.dataArray[ieuler + 1] = prtcl.euler[1]; pointFlower.dataArray[ieuler + 2] = prtcl.euler[2]; ieuler += 3;
                    pointFlower.dataArray[imisc] = prtcl.size; pointFlower.dataArray[imisc + 1] = prtcl.alpha; imisc += 2;
                }
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                var prog = pointFlower.program;
                useShader(prog);
                gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix);
                gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix);
                gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);
                gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof));
                gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader));
                gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW);
                gl.vertexAttribPointer(prog.attributes.aPosition, 3, gl.FLOAT, false, 0, pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT);
                gl.vertexAttribPointer(prog.attributes.aEuler, 3, gl.FLOAT, false, 0, pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT);
                gl.vertexAttribPointer(prog.attributes.aMisc, 2, gl.FLOAT, false, 0, pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT);
                for(var i = 1; i < 2; i++) {
                    var zpos = i * -2.0;
                    pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos;
                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);
                    pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y *  1.0; pointFlower.offset[2] = pointFlower.area.z * zpos;
                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);
                    pointFlower.offset[0] = pointFlower.area.x *  1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos;
                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);
                    pointFlower.offset[0] = pointFlower.area.x *  1.0; pointFlower.offset[1] = pointFlower.area.y *  1.0; pointFlower.offset[2] = pointFlower.area.z * zpos;
                    gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);
                }
                pointFlower.offset[0] = 0.0; pointFlower.offset[1] = 0.0; pointFlower.offset[2] = 0.0;
                gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset);
                gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                unuseShader(prog);
                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.BLEND);
            }
            function createEffectProgram(vtxsrc, frgsrc, exunifs, exattrs) {
                var ret = {};
                var unifs = ['uResolution', 'uSrc', 'uDelta'];
                if(exunifs) unifs = unifs.concat(exunifs);
                var attrs = ['aPosition'];
                if(exattrs) attrs = attrs.concat(exattrs);
                ret.program = createShader(vtxsrc, frgsrc, unifs, attrs);
                useShader(ret.program);
                ret.dataArray = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]);
                ret.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                unuseShader(ret.program);
                return ret;
            }
            function useEffect(fxobj, srctex) {
                var prog = fxobj.program;
                useShader(prog);
                gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array);
                if(srctex != null) {
                    gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray);
                    gl.uniform1i(prog.uniforms.uSrc, 0);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, srctex.texture);
                }
            }
            function drawEffect(fxobj) {
                gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer);
                gl.vertexAttribPointer(fxobj.program.attributes.aPosition, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
            function unuseEffect(fxobj) { unuseShader(fxobj.program); }
            var effectLib = {};
            function createEffectLib() {
                var vtxsrc, frgsrc;
                var cmnvtxsrc = document.getElementById("fx_common_vsh").textContent;
                frgsrc = document.getElementById("bg_fsh").textContent;
                effectLib.sceneBg = createEffectProgram(cmnvtxsrc, frgsrc, ['uTimes'], null);
                frgsrc = document.getElementById("fx_brightbuf_fsh").textContent;
                effectLib.mkBrightBuf = createEffectProgram(cmnvtxsrc, frgsrc, null, null);
                frgsrc = document.getElementById("fx_dirblur_r4_fsh").textContent;
                effectLib.dirBlur = createEffectProgram(cmnvtxsrc, frgsrc, ['uBlurDir'], null);
                vtxsrc = document.getElementById("pp_final_vsh").textContent;
                frgsrc = document.getElementById("pp_final_fsh").textContent;
                effectLib.finalComp = createEffectProgram(vtxsrc, frgsrc, ['uBloom'], null);
            }
            function createBackground() {}
            function initBackground() {}
            function renderBackground() {
                gl.disable(gl.DEPTH_TEST);
                useEffect(effectLib.sceneBg, null);
                gl.uniform2f(effectLib.sceneBg.program.uniforms.uTimes, timeInfo.elapsed, timeInfo.delta);
                drawEffect(effectLib.sceneBg);
                unuseEffect(effectLib.sceneBg);
                gl.enable(gl.DEPTH_TEST);
            }
            var postProcess = {};
            function createPostProcess() {}
            function initPostProcess() {}
            function renderPostProcess() {
                gl.enable(gl.TEXTURE_2D);
                gl.disable(gl.DEPTH_TEST);
                var bindRT = function (rt, isclear) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer);
                    gl.viewport(0, 0, rt.width, rt.height);
                    if(isclear) { gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); }
                };
                bindRT(renderSpec.wHalfRT0, true);
                useEffect(effectLib.mkBrightBuf, renderSpec.mainRT);
                drawEffect(effectLib.mkBrightBuf);
                unuseEffect(effectLib.mkBrightBuf);
                for(var i = 0; i < 2; i++) {
                    var p = 1.5 + 1 * i;
                    var s = 2.0 + 1 * i;
                    bindRT(renderSpec.wHalfRT1, true);
                    useEffect(effectLib.dirBlur, renderSpec.wHalfRT0);
                    gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, p, 0.0, s, 0.0);
                    drawEffect(effectLib.dirBlur);
                    unuseEffect(effectLib.dirBlur);
                    bindRT(renderSpec.wHalfRT0, true);
                    useEffect(effectLib.dirBlur, renderSpec.wHalfRT1);
                    gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, 0.0, p, 0.0, s);
                    drawEffect(effectLib.dirBlur);
                    unuseEffect(effectLib.dirBlur);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, renderSpec.width, renderSpec.height);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                useEffect(effectLib.finalComp, renderSpec.mainRT);
                gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture);
                drawEffect(effectLib.finalComp);
                unuseEffect(effectLib.finalComp);
                gl.enable(gl.DEPTH_TEST);
            }
            var SceneEnv = {};
            function createScene() { createEffectLib(); createBackground(); createPointFlowers(); createPostProcess(); sceneStandBy = true; }
            function initScene() {
                initBackground(); initPointFlowers(); initPostProcess();
                camera.position.z = pointFlower.area.z + projection.nearfar[0];
                projection.angle = Math.atan2(pointFlower.area.y, camera.position.z + pointFlower.area.z) * 180.0 / Math.PI * 2.0;
                Matrix44.loadProjection(projection.matrix, renderSpec.aspect, projection.angle, projection.nearfar[0], projection.nearfar[1]);
            }
            function renderScene() {
                Matrix44.loadLookAt(camera.matrix, camera.position, camera.lookat, camera.up);
                gl.enable(gl.DEPTH_TEST);
                gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer);
                gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height);
                gl.clearColor(0.005, 0, 0.05, 0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                renderBackground(); renderPointFlowers(); renderPostProcess();
            }
            function onResize(e) {
                makeCanvasFullScreen(document.getElementById("sakura"));
                setViewports();
                if(sceneStandBy) initScene();
            }
            function setViewports() {
                renderSpec.setSize(gl.canvas.width, gl.canvas.height);
                gl.clearColor(0.2, 0.2, 0.5, 1.0);
                gl.viewport(0, 0, renderSpec.width, renderSpec.height);
                var rtfunc = function (rtname, rtw, rth) {
                    var rt = renderSpec[rtname];
                    if(rt) deleteRenderTarget(rt);
                    renderSpec[rtname] = createRenderTarget(rtw, rth);
                };
                rtfunc('mainRT', renderSpec.width, renderSpec.height);
                rtfunc('wFullRT0', renderSpec.width, renderSpec.height);
                rtfunc('wFullRT1', renderSpec.width, renderSpec.height);
                rtfunc('wHalfRT0', renderSpec.halfWidth, renderSpec.halfHeight);
                rtfunc('wHalfRT1', renderSpec.halfWidth, renderSpec.halfHeight);
            }
            function render() { renderScene(); }
            var animating = true;
            function toggleAnimation(elm) {
                animating ^= true;
                if(animating) animate();
                if(elm) elm.innerHTML = animating? "Stop":"Start";
            }
            function stepAnimation() { if(!animating) animate(); }
            function animate() {
                var curdate = new Date();
                timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0;
                timeInfo.delta = (curdate - timeInfo.prev) / 1000.0;
                timeInfo.prev = curdate;
                if(animating) requestAnimationFrame(animate);
                render();
            }
            function makeCanvasFullScreen(canvas) {
                var b = document.body;
                var d = document.documentElement;
                fullw = Math.max(b.clientWidth , b.scrollWidth, d.scrollWidth, d.clientWidth);
                fullh = Math.max(b.clientHeight , b.scrollHeight, d.scrollHeight, d.clientHeight);
                canvas.width = fullw;
                canvas.height = fullh;
            }
            window.addEventListener('load', function(e) {
                var canvas = document.getElementById("sakura");
                try {
                    makeCanvasFullScreen(canvas);
                    gl = canvas.getContext('experimental-webgl');
                } catch(e) { console.error("WebGL not supported." + e); return; }
                window.addEventListener('resize', onResize);
                setViewports();
                createScene();
                initScene();
                timeInfo.start = new Date();
                timeInfo.prev = timeInfo.start;
                animate();
            });
            (function (w, r) { w['r'+r] = w['r'+r] || w['webkitR'+r] || w['mozR'+r] || w['msR'+r] || w['oR'+r] || function(c){ w.setTimeout(c, 1000 / 60); }; })(window, 'equestAnimationFrame');
        })();


    </script>


 <script>
     // Part B: 页面交互逻辑
     // =========================================
    document.addEventListener('DOMContentLoaded', function() {

    // ==================== 1. 密码显示/隐藏功能 ====================
    const togglePassword = document.getElementById('togglePassword');
    const passwordInput = document.getElementById('password');

    if (togglePassword && passwordInput) {
        togglePassword.addEventListener('click', function() {
            // 切换密码框类型
            const isPassword = passwordInput.getAttribute('type') === 'password';
            passwordInput.setAttribute('type', isPassword ? 'text' : 'password');

            // 切换图标颜色（显示时变粉色，隐藏时变灰色）
            this.style.color = isPassword ? 'var(--primary-color)' : '#aaa';
        });
    }

    const loginForm = document.getElementById('loginForm');
    const submitBtn = document.getElementById('submitBtn');
    const emailInput = document.getElementById('email');


    // 2. 绑定提交事件
    loginForm.addEventListener('submit', function(e) {
        e.preventDefault(); // 【关键】阻止表单默认的提交跳转行为，改用 JS 控制发送

        // 简单校验
        if (!emailInput.value || !passwordInput.value) {
            alert('请输入邮箱和密码');
            return;
        }

        startLoading();


        fetch('/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: emailInput.value, password: passwordInput.value })
        })
        .then(response => response.json()) // 解析 JSON
        .then(data => {
            if (data.status === "success") {
                window.location.href = data.redirect;
            } else {
                alert(data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('发生错误，请稍后重试');
        })
        .finally(() => {
            stopLoading();
        });
    });

    // 工具函数：开始加载状态
    function startLoading() {
        // 加个判断，防止报错
        if (submitBtn) {
            submitBtn.classList.add('loading');
            submitBtn.disabled = true;
        }
        if (emailInput) emailInput.disabled = true;
        if (passwordInput) passwordInput.disabled = true;
    }

    // 工具函数：结束加载状态
    function stopLoading() {
        if (submitBtn) {
            submitBtn.classList.remove('loading');
            submitBtn.disabled = false;
        }
        if (emailInput) emailInput.disabled = false;
        if (passwordInput) passwordInput.disabled = false;
    }
});

 </script>
</body>
</html>
